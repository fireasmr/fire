------------------multiple doc's extraction---------------------

from scapy.all import rdpcap, Raw, TCP, IP

def extract_docx_multiple(pcap_file, output_dir):
    packets = rdpcap(pcap_file)
    data_stream = bytearray()

    start = b'\x50\x4B\x03\x04'
    end = b'\x50\x4B\x05\x06'
    docx_count = 0

    for pkt in packets:
        if pkt.haslayer(IP) and pkt.haslayer(TCP) and pkt.haslayer(Raw):
            data_stream += pkt[Raw].load

    index = 0
    while True:
        start_idx = data_stream.find(start, index)
        if start_idx == -1:
            break
        end_idx = data_stream.find(end, start_idx)
        if end_idx == -1:
            break
        end_idx += 22
        docx_data = data_stream[start_idx:end_idx]
        output_file = f"{output_dir}/extracted_{docx_count + 1}.docx"
        with open(output_file, 'wb') as f:
            f.write(docx_data)
        print(f"Saved DOCX {docx_count + 1} to {output_file}")
        docx_count += 1
        index = end_idx

    if docx_count == 0:
        print("No DOCX found in capture.")
    else:
        print(f"Total DOCX files extracted: {docx_count}")

extract_docx_multiple(
    "multidoc.pcapng", "./extracted_docs"
)

-------------single doc extraction-------------
from scapy.all import rdpcap, Raw, TCP, IP

def extract_docx(pcap_file, output_file):
    packets = rdpcap(pcap_file)
    docx_data = bytearray()
    found = False
    sig1 = b'\x50\x4B\x03\x04'
    sig2 = b'\x50\x4B\x03\x04\x4B\x50'

    for pkt in packets:
        if pkt.haslayer(IP) and pkt.haslayer(TCP) and pkt.haslayer(Raw):
            data = pkt[Raw].load
            if not found:
                if sig1 in data:
                    found = True
                    docx_data += data[data.index(sig1):]
                    print("Found DOCX start (sig1)")
                elif sig2 in data:
                    found = True
                    docx_data += data[data.index(sig2):]
                    print("Found DOCX start (sig2)")
            else:
                docx_data += data

    if docx_data:
        with open(output_file, 'wb') as f:
            f.write(docx_data)
        print(f"Saved DOCX to {output_file}")
    else:
        print("No DOCX found in capture.")

extract_docx(r"Z:\FTP-FILECARVE.pcapng", "extracted1.docx")
------------wireshark help-----------------

Display filters (easy, use in the filter bar)

All HTTP packets
http

HTTP requests only
http.request

HTTP responses only
http.response

Specific HTTP method (GET/POST/PUT/DELETE, etc.)
http.request.method == "GET"
http.request.method == "POST"

Specific status code or range
http.response.code == 200
http.response.code >= 400 and http.response.code < 600

Filter by Host header or domain
http.host == "example.com"
http.host contains "example"

Filter by request URI or path fragment
http.request.uri contains "/login"
http.request.full_uri contains "example.com/path"

Filter by content-type (responses or requests with bodies)
http.content_type == "application/json"
http.content_type contains "text/html"

Filter by User-Agent
http.user_agent contains "Mozilla"

Filter by Cookie or Authorization header
http.cookie
http.authorization
http.authorization contains "Bearer"

Show packets containing file downloads / attachments
http.content_disposition
or http.content_type contains "application/octet-stream"

Match with regex (PCRE)
http.host matches ".*example.*"

http.request.uri matches "/api/v[0-9]+/.*"

Combine conditions (AND / OR / NOT)
http.request.method == "POST" and http.host == "api.example.com"
http and not http.request.method == "OPTIONS"

Show POST requests (often with bodies)
http.request.method == "POST"

Show responses with a specific phrase (reason)
http.response.phrase contains "Not Found"

Capture HTTP on standard port 80 (all hosts)
tcp port 80

Capture traffic to/from a specific host on port 80
host 10.0.0.5 and tcp port 80

Capture only traffic destined to port 80 (server-bound)
tcp dst port 80

Capture HTTPS (TLS) on port 443
tcp port 443

Capture either 80 or 443
tcp port 80 or tcp port 443

Show failed login attempts (POSTs returning 401/403):
http.request.method == "POST" and (http.response.code == 401 or http.response.code == 403)

Show image responses (jpg/png)
http.content_type contains "image/"

Find requests to a specific API path and view their responses:
http.request.uri contains "/api/v1/orders"

Request-focused filters

Show all request URIs:
http.request.uri

Show requests with query parameters:
http.request.uri contains "?"

Requests with JSON body:
http.request.method == "POST" and http.content_type contains "application/json"

Requests with form data (e.g., login forms):
http.content_type == "application/x-www-form-urlencoded"

Requests with large payload (>1KB):
http.request and frame.len > 1000

Requests missing Host header:
http.request and not http.host
Response-focused filters

Responses larger than 100 KB:
http.response and frame.len > 100000

Redirects (301, 302, 307, 308):
http.response.code >= 300 and http.response.code < 400

Server errors:
http.response.code >= 500

Responses with JSON:
http.content_type contains "json"

Responses with HTML:
http.content_type contains "text/html"

Responses with gzip compression:
http.content_encoding == "gzip"

Header-specific filters

Look at Referrer headers:
http.referer

Requests with specific referrer:
http.referer contains "google.com"

Requests with Authorization header (often API calls):
http.authorization

Requests with Basic authentication:
http.authorization contains "Basic"

Requests with Bearer tokens:
http.authorization contains "Bearer"

Requests containing cookies:
http.cookie

Requests containing session cookies:
http.cookie contains "session"

Responses setting cookies:
http.set_cookie

Debugging/troubleshooting filters

Only requests with missing responses:
http.request and not http.response_in

Only responses without request info:
http.response and not http.request_in

Show connections where response time is long (>1s):
http.time > 1

Requests to multiple subdomains:
http.host matches ".*\.example\.com"

Requests where User-Agent indicates mobile:
http.user_agent contains "Mobile"

HTTP/2 traffic:
http2

TLS handshake failures:
tls.alert_message

Certificates exchanged:
tls.handshake.certificate

→ Find failing API calls

http and frame.len > 2000 and http.content_type contains "json"
→ Large JSON API responses

http.request and http.user_agent contains "curl"

----------y------finish-----

------------v--- start----------

== equals  
!= not equals  
> , < , >= , <= numeric comparisons  
contains payload/substring check (case-sensitive)  
matches regex (PCRE)    
&& logical AND  
|| logical OR  
! logical NOT (prefix)  
() grouping  

frame.number == 123 — specific frame  
frame.len > 1500 — frames bigger than MTU  
frame.time_delta — inter-frame time (useful for timing analysis)  
frame contains "password" — raw frame contains string  

eth.src == 00:11:22:33:44:55 — source MAC  
eth.dst == ff:ff:ff:ff:ff:ff — broadcast  
vlan.id == 100 — VLAN tag  

ip.addr == 192.168.1.5 — source or destination IP  
ip.src == 10.0.0.1 — source IP  
ip.dst == 10.0.0.2 — destination IP  
ip.proto == 6 — protocol number (6 = TCP)  
ip.ttl <= 5 — TTL based filter  
ipv6.addr == 2001:db8::1 — IPv6 address  
ipv6.nxt == 6 — IPv6 next header  

tcp.port == 443 — any TCP port 443 traffic  
udp.port == 53 — any UDP port 53 traffic  
tcp.srcport == 22 — TCP source port 22  
udp.dstport == 500 — UDP destination port 500  
tcp.flags.syn == 1 — SYN flag set  
tcp.flags.ack == 1 — ACK flag set  
tcp.flags.reset == 1 — RST flag set  
tcp.flags.fin == 1 — FIN flag set  
tcp.flags.syn == 1 && tcp.flags.ack == 0 — SYN only (new connection)  
tcp.seq — TCP sequence number  
tcp.ack — TCP acknowledgment number  

http — any HTTP traffic  
http.request — HTTP request  
http.response — HTTP response  
http.request.method == "GET" — HTTP GET request  
http.request.method == "POST" — HTTP POST request  
http.response.code == 200 — HTTP 200 OK  
http.response.code == 404 — HTTP 404 Not Found  
http.host == "example.com" — HTTP Host header  
http.user_agent contains "Firefox" — HTTP User-Agent header  
http.request.uri contains "/login" — HTTP URI  

dns — any DNS traffic  
dns.qry.name == "example.com" — DNS query name  
dns.flags.response == 0 — DNS queries only  
dns.flags.response == 1 — DNS responses only  
dns.qry.type == 1 — A record query  

tls — TLS traffic  
tls.handshake.type == 1 — TLS ClientHello  
tls.handshake.type == 2 — TLS ServerHello  
tls.record.version == 0x0303 — TLS 1.2  

arp — ARP traffic  
arp.opcode == 1 — ARP request  
arp.opcode == 2 — ARP reply  

icmp — ICMP traffic  
icmp.type == 8 — echo request (ping request)  
icmp.type == 0 — echo reply (ping reply)  

frame.len > 1400 — large frames  
tcp.analysis.retransmission — TCP retransmissions  
tcp.analysis.fast_retransmission — fast retransmissions  
tcp.analysis.flags — TCP analysis flags  
tcp.stream == 5 — specific TCP stream  

!(eth.dst == ff:ff:ff:ff:ff:ff) — exclude broadcast  
!(arp || icmp) — exclude ARP and ICMP  
!(arp || icmp || bootp || dhcp) — exclude ARP, ICMP, DHCP

---regex part----------
1.	Dot (.) any char

http.host matches "a.c"


	2.	Asterisk (*) zero or more

http.request.uri matches "a*"


	3.	Plus (+) one or more

http.user_agent matches "Mozilla+"


	4.	Question mark (?) optional

http.request.uri matches "colou?r"


	5.	Brackets [ ] set

http.host matches "[abc]"


	6.	Negated set [^ ] not in set

http.host matches "[^abc]"


	7.	Caret (^) start of string

http.request.uri matches "^/api"


	8.	Dollar ($) end of string

http.host matches ".com$"


	9.	OR (|)

http.request.uri matches "login|signup"


	10.	Grouping ( )

http.request.uri matches "(login|signup)"

	11.	Escape (\)

http.host matches "example\\.com"

	12.	Case-insensitive (?i)

http.request.uri matches "(?i)login"




http.request.uri matches "^/api/v1/.*\\.json$"


	•	Query params with token/key:

http.request.uri matches "(token|key)="


	•	Auth header with Bearer (case-insensitive):

http.authorization matches "(?i)Bearer"


	•	Hosts ending with .gov or .edu:

http.host matches "\\.(gov|edu)$"
------------hex codes - header/footer -----------------

JPEG -  FF D8 FF E0
JPEG FOOTER - FF D9
PNG - 89 50 4E 47 0D 0A 1A 0A
DOCX - 50 4B 03 04
PDF - 25 50 44 46
DOC - D0 CF 11 E0 A1 B1 1A E1

-----------------------------wireshark cheat sheet -------------------------------
Capture only traffic to or from IP address 172.18.5.4:
● host 172.18.5.4
Capture traffic to or from a range of IP addresses:
● net 192.168.0.0/24
or
● net 192.168.0.0 mask 255.255.255.0
Capture traffic from a range of IP addresses:
● src net 192.168.0.0/24
or
● src net 192.168.0.0 mask 255.255.255.0
Capture traffic to a range of IP addresses:
● dst net 192.168.0.0/24
or
● dst net 192.168.0.0 mask 255.255.255.0
Capture only DNS (port 53) traffic:
● port 53
Capture non-HTTP and non-SMTP traffic on your server (both are equivalent):
● host www.example.com and not (port 80 or port 25)
host www.example.com and not port 80 and not port 25
Capture except all ARP and DNS traffic:
● port not 53 and not arp
Capture traffic within a range of ports
● (tcp[0:2] > 1500 and tcp[0:2] < 1550) or (tcp[2:2] > 1500 and tcp[2:2] < 1550)
or, with newer versions of libpcap (0.9.1 and later):
● tcp portrange 1501-1549
Capture only Ethernet type EAPOL:
● ether proto 0x888e
Reject ethernet frames towards the Link Layer Discovery Protocol Multicast group:
● not ether dst 01:80:c2:00:00:0e
Capture only IPv4 traffic - the shortest filter, but sometimes very useful to get rid of lower layer
protocols like ARP and STP:
● ip
Capture only unicast traffic - useful to get rid of noise on the network if you only want to see traffic
to and from your machine, not, for example, broadcast and multicast announcements:
● not broadcast and not multicast
Capture IPv6 "all nodes" (router and neighbor advertisement) traffic. Can be used to find rogue
RAs:
● dst host ff02::1
Capture HTTP GET requests. This looks for the bytes 'G', 'E', 'T', and ' ' (hex values 47, 45, 54, and
20) just after the TCP header. "tcp[12:1] & 0xf0) >> 2" figures out the TCP header length.
● port 80 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420
Useful Filters
Blaster and Welchia are RPC worms. (Does anyone have better links, i.e. ones that describe or
show the actual payload?)
Blaster worm:
● dst port 135 and tcp port 135 and ip[2:2]==48
Welchia worm:
● icmp[icmptype]==icmp-echo and ip[2:2]==92 and icmp[8:4]==0xAAAAAAAA
The filter looks for an icmp echo request that is 92 bytes long and has an icmp payload that begins
with 4 bytes of A's (hex). It is the signature of the welchia worm just before it tries to
compromise a system.
Many worms try to spread by contacting other hosts on ports 135, 445, or 1433. This filter is
independent of the specific worm instead it looks for SYN packets originating from a local network
on those specific ports. Please change the network filter to reflect your own network.
dst port 135 or dst port 445 or dst port 1433 and tcp[tcpflags] & (tcp-syn) != 0
and tcp[tcpflags] & (tcp-ack) = 0 and src net 192.168.0.0/24
Heartbleed Exploit:
● tcp src port 443 and (tcp[((tcp[12] & 0xF0) >> 4 ) * 4] = 0x18) and
(tcp[((tcp[12] & 0xF0) >> 4 ) * 4 + 1] = 0x03) and (tcp[((tcp[12] & 0xF0) >> 4
) * 4 + 2] < 0x04) and ((ip[2:2] - 4 * (ip[0] & 0x0F) - 4 * ((tcp[12] & 0xF0)
>> 4) > 69))

SSH_CONNECTION not (tcp port srcport and addr_family host srchost and tcp
port dstport and addr_family host dsthost)

SSH_CLIENT not (tcp port srcport and addr_family host srchost and tcp
port dstport)

REMOTEHOST not addr_family host host

DISPLAY not addr_family host host

CLIENTNAME not tcp port 3389

Discussion
BTW, the Symantec page says that Blaster probes 135/tcp, 4444/tcp, and 69/udp. Would
● (tcp dst port 135 or tcp dst port 4444 or udp dst port 69) and ip[2:2]==48
● be a better filter? - Gerald Combs
Q: What is a good filter for just capturing SIP and RTP packets?
A: On most systems, for SIP traffic to the standard SIP port 5060,
● tcp port sip
should capture TCP traffic to and from that port,
● udp port sip
should capture UDP traffic to and from that port, and
● port sip

should capture both TCP and UDP traffic to and from that port (if one of those filters gets "parse
error", try using 5060 instead of sip). For SIP traffic to and from other ports, use that port number
rather than sip.
In most cases RTP port numbers are dynamically assigned. You can use something like the
following which limits the capture to UDP, even source and destination ports, a valid RTP version,
and small packets. It will capture any non-RTP traffic that happens to match the filter (such as DNS)
but it will capture all RTP packets in many environments.
● udp[1] & 1 != 1 && udp[3] & 1 != 1 && udp[8] & 0x80 == 0x80 && length < 250
Capture WLAN traffic without Beacons:
● link[0] != 0x80
Capture all traffic originating (source) in the IP range 192.168.XXX.XXX:
● src net 192.168
Capture PPPoE traffic:
● pppoes
● pppoes and (host 192.168.0.0 and port 80)
Capture VLAN traffic:
● vlan
● vlan and (host 192.168.0.0 and port 80)

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------

from scapy.all import rdpcap, Raw, TCP, IP
from collections import defaultdict

def extract_files_from_stream(pcap_file, output_file):
    packets = rdpcap(pcap_file)
    sessions = defaultdict(list)

    for pkt in packets:
        if pkt.haslayer(TCP) and pkt.haslayer(Raw) and pkt.haslayer(IP):
            src_ip, sport = pkt[IP].src, pkt[TCP].sport
            dst_ip, dport = pkt[IP].dst, pkt[TCP].dport
            session_key = tuple(sorted(((src_ip, sport), (dst_ip, dport))))
            sessions[session_key].append(pkt)
    
    start_sig = b'\x50\x4B\x03\x04'
    end_sig = b'\x50\x4B\x05\x06'
    file_found = False

    for session_key, session_packets in sessions.items():
        sorted_packets = sorted(session_packets, key=lambda p: p[TCP].seq)
        full_payload = b"".join(p[Raw].load for p in sorted_packets)
                
        start_index = full_payload.find(start_sig)
        
        if start_index != -1:            
            end_index = full_payload.rfind(end_sig)
            if end_index != -1 and end_index > start_index:
                file_data = full_payload[start_index : end_index + 22]
                try:
                    with open(output_file, 'wb') as f:
                        f.write(file_data)
                    print(f"  [SUCCESS] Saved extracted file to {output_file}")
                    file_found = True
                    return
                except Exception as e:
                    print(f"  [ERROR] Could not write to file: {e}")
                    return

    if not file_found:
        print("\nCould not find a complete DOCX file in any TCP stream.")

extract_files_from_stream(r'/Users/tharageshtharun/Downloads/captures.pcapng', "/Users/tharageshtharun/Downloads/extracted.docx")
-------------------------------------------------above is tg's -------------- code
